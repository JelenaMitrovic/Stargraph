
processor = {
  stop-property-filter = [
    "^rdf:type$"
  ]

  regex-filter = {
    s: null
    p: null
    o: null
  }

  entity-splitter = {}

  sink-duplicate = {}

  entity-classifier = {
    relations = [
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
      "rdf:type",
      "http://purl.org/dc/terms/subject",
      "dct:subject"
    ]
  }

  namespace = {
    dbr: "http://dbpedia.org/resource/"
    dbp: "http://dbpedia.org/property/"
    dbo: "http://dbpedia.org/ontology/"
    dbc: "http://dbpedia.org/resource/Category:"
    rdfs: "http://www.w3.org/2000/01/rdf-schema#"
    schema: "http://schema.org/"
    dct: "http://purl.org/dc/terms/"
  }

  wordnet = {
    wordnet-dir = /usr/share/wordnet
  }
}

stargraph.opennlp.models-dir = /usr/share/stargraph/opennlp

stargraph.rules = {
  #
  # Each supported language must have a section of rules here.
  #

  syntatic-pattern.en = [

    # Must map to the Model Types:
    #  INSTANCE, CLASS, COMPLEX_CLASS, PROPERTY, VARIABLE, VALUE, OPERATION,
    #  POS, TEMPORAL, TYPE, STOP, ATCLASS
    #
    # The order is relevant. Split the array if need to interleave rules.

    {
      OPERATION: [
        "same type as",
        "same",
        "second highest",
        "largest",
        "highest after",
        "first",
        "more than",
        "less than",
        "earlier than",
        "between",
        "more",
        "less",
        "most",
        "past",
        "still",
        "also"
      ]
    }

    {
      OPERATION: [
        "JJR IN",
        "JJ JJS",
        "JJS"
      ]
    }

    {
      INSTANCE: [
        ".*IN DT (NNP NNPS CC NNP NNP).+$",
        ".*VBD (DT NN IN DT NN IN NNP).+$",
        ".*VBD (NNP , NNP CC NNP) VB.+$",
        ".*IN (NNP , NNP).+$",
        ".*VBD (NNP CC NNP).+$",
        ".*IN (NNP CC NNP).+$",
        "NNP IN NNPS NNP",
        "NNP NNP IN NNP",
        "NNP NNP PRP",
        "NNP IN NNP",
        "NNP NNP NNP",
        "JJ NNP NNP",
        "JJ NNP",
        "NNP NNP CD",
        "NNP CD NNP",
        "NNP NNP",
        "JJ INSTANCE",
        "NNP CD"
      ]
    }

    {
      CLASS: [
        ".*WDT (NNP NNS) .+$",
        ".*WDT (NNP NN) .+$",
      ]
    }

    {
      INSTANCE: [
        "NNPS",
        "NNP",
      ]
    }

    {
      CLASS: [
        "NNS IN JJ NN",
        "NN IN JJ NN",
        "JJ NNS NNS",
        "JJ NN NNS",
        "NN NN NNS",
        "NN NN NN"
      ]
    }

    {
      ATCLASS: [
        ".*WDT (JJ NNS) .+$",
        ".*WDT (JJ NN) .+$"
      ]
    }

    {
      CLASS: [
        ".*DT (NNS) IN .+$",
        ".*DT (NN) IN .+$"
      ]
    }

    {
      TYPE: [
        "is the",
        "are the",
        "a type"
      ]
    }

    {
      PROPERTY: [
        "VBZ VBN VBN",
        "VBZ VBN VBN",
        "VBG TO VB",
        "VBP VBN",
        "VBD VBN",
        "VBP NN",
        "POS NNS NNS",
        "POS NN NN",
        "POS NN",
      ]
    }

    {
      CLASS: [".*DT (NN) INSTANCE .+$"]
    }

    {
      ATCLASS: [
        ".*WDT (NNS) .+$",
        ".*WDT (NN) .+$"
      ]
    }

    {
      PROPERTY: [
        ".*(VBD NN NNS) IN .+$",
        ".* CD (NNS) .+$",
        ".* CD (NN) .+$",
        "VBG",
        "VBN",
        "VBP",
        "VBD",
        "VBZ",
        "VB"
      ]
    }

    {
      POS: ["POS"]
    }

    {
      CLASS: [
        "JJ JJ NNS",
        "JJ JJ NN",
        ".*WDT (NNP NNP NN).+$",
        ".*DT (JJ NN IN NN) VB.+$",
        ".*DT (JJ NN IN NNP) VB.+$",
        ".*VBZ DT (JJ NNP NN).+$",
        ".*DT (NNP NN) VB.+$"
      ]
    }

    {
      ATCLASS: [
        ".*WDT (NNP NNS).+$",
        ".*WDT (NNP NN).+$"
      ]
    }

    {
      CLASS: [
        ".*IN (NN).+$",
        "NNP NNP NN",
        "NNP NN NN",
        "NNP NNS",
        "NN JJ NNS",
        "NN NNS",
        "NNS NNS",
        "NN NN",
        "JJ NNS",
        "JJ NN",
        "NNP NN"
      ]
    }

    {
      VALUE: [
        "CD CD",
        "CD"
      ]
    }
  ]

  planner-pattern.en = {
    "CLASS_1 INSTANCE_1": [
      "INSTANCE_1 CLASS_1 ?VAR_1"
    ]
  }

  query-pattern.en = {
    ASK: [
      "^[i|I]s .+\\?$",
      "^[a|A]re .+\\?$",
      "^[w|W]as .+\\?$",
      "^[w|W]ere .+\\?$",
      "^[d|D]id .+\\?$",
      "^[d|D]o .+\\?$",
      "^[d|D]oes .+\\?$"
    ]

    SELECT: [
      "^[g|G]ive .+$",
      "^[s|S]how .+$",
      "^[n|N]ame .+$",
      "^[l|L]ist .+$",
      "^[w|W]hat .+\\?$",
      "^[w|W]here .+\\?$",
      "^[w|W]ho .+\\?$",
      "^[w|W]hich .+\\?$",
      "^[w|W]hen .+\\?$",
      "^[h|H]ow .+\\?$"
    ]

    AGGREGATE: [
      "^[h|H]ow many .+\\?$",
      "^[h|H]ow often .+\\?$"
    ]
  }

}


stargraph = {
  data.root-dir = /usr/share/stargraph/data
  networking.rest-url = "http://localhost:8917"

  distributional-service.rest-url = "http://localhost:8916/relatedness"
  distributional-service.corpus = wiki-2014

  elastic.bulk.concurrency = 0 # means all CPUs available
  elastic.bulk.actions = 1000
  elastic.cluster-name = StarGraphV2Cluster
  elastic.servers = ["localhost:9300"]
  elastic.index.prefix-name = null

  #
  # These are the default supported indexed types.
  # New models should declare their own type or rely on the _default_ dynamic model.
  # As expected the key names are reserved for the built-in models.
  #
  elastic.mapping = {

    "_default_": {
      "dynamic_templates": [
        {
          "objects": {
            "match": "*",
            "match_mapping_type": "object",
            "mapping": {
              "type": "nested",
              "include_in_parent": true
            }
          }
        }
      ]
    }

    "entities": {
      "dynamic": "strict",
      "include_in_all": false,
      "properties": {
        "id": {
          "type": "keyword",
          "index": true
          "doc_values": false
        },
        "value": {
          "type": "text",
          "analyzer": "english",
          "doc_values": false
        },
        "otherValues": {
          "type": "text",
          "analyzer": "english",
          "doc_values": false
        }
      }
    }

    "relations": {
      "dynamic": "strict",
      "include_in_all": false,
      "properties": {
        "id": {
          "type": "keyword",
          "index": false,
          "doc_values": false
        },
        "value": {
          "type": "text",
          "analyzer": "english",
          "doc_values": false
        },
        "synonyms": {
          "type": "nested",
          "properties": {
            "posType": {
              "type": "keyword",
              "index": false,
              "doc_values": false
            },
            "word": {
              "type": "text",
              "analyzer": "english",
              "doc_values": false
            }
          }
        },
        "hyponyms": {
          "type": "nested",
          "properties": {
            "posType": {
              "type": "keyword",
              "index": false,
              "doc_values": false
            },
            "word": {
              "type": "text",
              "analyzer": "english",
              "doc_values": false
            }
          }
        },
        "hypernyms": {
          "type": "nested",
          "properties": {
            "posType": {
              "type": "keyword",
              "index": false,
              "doc_values": false
            },
            "word": {
              "type": "text",
              "analyzer": "english",
              "doc_values": false
            }
          }
        }
      }
    }

    "facts": {
      "dynamic": "strict",
      "include_in_all": false,
      "properties": {
        "s": {
          "type": "nested",
          "properties": {
            "id": {
              "type": "keyword",
              "index": true
              "doc_values": false
            },
            "value": {
              "type": "text",
              "analyzer": "english",
              "doc_values": false
            },
            "otherValues": {
              "type": "text",
              "analyzer": "english",
              "doc_values": false
            }
          }
        },
        "p": {
          "type": "nested",
          "properties": {
            "id": {
              "type": "keyword",
              "index": true,
              "doc_values": false
            },
            "value": {
              "type": "text",
              "analyzer": "english",
              "doc_values": false
            }
          }
        },
        "o": {
          "type": "nested",
          "properties": {
            "complex": {
              "type": "boolean",
              "index": true,
              "doc_values": false
            }
            "id": {
              "type": "keyword",
              "index": true,
              "doc_values": false
            },
            "value": {
              "type": "text",
              "analyzer": "english",
              "doc_values": false
            },
            "otherValues": {
              "type": "text",
              "analyzer": "english",
              "doc_values": false
            },
            "dataType": {
              "type": "keyword",
              "index": false,
              "doc_values": false
            },
            "language": {
              "type": "keyword",
              "index": false,
              "doc_values": false
            }
          }
        }
      }
    }
  }

  kb: null
  indexer.factory.class = net.stargraph.core.index.DefaultIndexerFactory
}